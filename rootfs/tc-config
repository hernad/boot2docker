#!/bin/busybox ash

# RC Script for Tiny Core Linux
# (c) Robert Shingledecker 2004-2012
# Several modifications for speed by Curaga

. /etc/green_common

log_msg "start $(date), called by /etc/init.d/rcS"

useBusybox

TCEDIR="/tmp/tce"
TCEOPT="/tmp/tce/optional"
TCLOOP="/tmp/tcloop"
TCEINSTALLED="/usr/local/tce.installed"
INSTALLED=""
VERSION="$(cat /usr/share/doc/tc/release.txt)"
KERNEL="$(uname -r)"

addUser() {
	echo "${GREEN}Adding user ${YELLOW}docker ${NORMAL}"
	/bin/adduser -s /bin/sh -G staff -D docker
	[ -n "$DOCKER_PASSWORD" ] && change_user_password docker $DOCKER_PASSWORD
	echo -e "docker\tALL=NOPASSWD: ALL" >> /etc/sudoers
}

### END functions

# Main

clear
echo "${GREEN}Booting greenbox ${YELLOW}Core $VERSION ${NORMAL}"
echo "${GREEN}Running Linux Kernel ${YELLOW}$KERNEL${GREEN}.${NORMAL}"

log_msg "set PATH /usr/local/sbin,bin etc ..."
PATH=/usr/local/sbin:/usr/local/bin:/bin:/sbin:/usr/bin:/usr/sbin

log_msg "Here we check all the boot parameters using the fastest way known to men, case & loop"
echo -n "${BLUE}Checking boot options...${NORMAL}"
for i in `cat /proc/cmdline`; do
	case $i in
		*=*)
			case $i in
				waitusb*) WAITUSB=${i#*=} ;;
				lang=*) LANGUAGE=${i#*=} ;;
				kmap*) KEYMAP=${i#*=} ;;
				tz=*) TZ=${i#*=} ;;
				staticip=*) STATICIPADDRESS=${i#*=} ;;
				staticiface=*) STATICIFACE=${i#*=} ;;
				ntpserver=*) NTPSERVER=${i#*=} ;;
				dockerpwd=*) DOCKER_PASSWORD=${i#*=} ;;
				rootpwd=*) ROOT_PASSWORD=${i#*=} ;;
				host=*) HOST=1 ;;
				nfsmount=* ) NFSMOUNT=${i#*=} ;;
				nbd=* ) NBD=${i#*=} ;;
				pretce=* ) PRETCE=${i#*=} ;;
				xvesa=* ) XVESA=${i#*=} ;;
				rsyslog=* ) RSYSLOG=${i#*=}; SYSLOG=1 ;;
				blacklist=* ) BLACKLIST="$BLACKLIST ${i#*=}" ;;
			esac
		;;
		*)
			case $i in
				nodockerstart) NODOCKERSTART=1 ;;
				nortc) NORTC=1 ;;
				syslog) SYSLOG=1 ;;
				noutc) NOUTC=1 ;;
				nodhcp) NODHCP=1 ;;
				superuser) SUPERUSER=1 ;;
				laptop) LAPTOP=1 ;;
				base) ONLYBASE=1 ;;
				showapps) SHOWAPPS=1 ;;
				norestore) NORESTORE=1 ;;
				noautologin) NOAUTOLOGIN=1 ;;
			esac
		;;
	esac
done
echo "${GREEN} Done.${NORMAL}"

log_msg "blacklist: $BLACKLIST"

if [ -n "$BLACKLIST" ]; then
	mkdir -p /etc/modprobe.d
	for i in $BLACKLIST; do
		echo "$i" | tr ',' '\n' | while read j ; do
			echo "blacklist $j" >> /etc/modprobe.d/blacklist.conf
		done
	done
fi

log_msg "Start Udev to populate /dev and handle hotplug events"
echo -n "${BLUE}Starting udev daemon for hotplug support...${NORMAL}"
/sbin/udevd --daemon 2>&1 >/dev/null
/sbin/udevadm trigger --action=add 2>&1 >/dev/null &
rotdash $!
echo "${GREEN} Done.${NORMAL}"

[ -n "$WAITUSB" ] && (
	case $WAITUSB in
		*:*) dev=${WAITUSB#*:}
		timeout=$((${WAITUSB%:*} * 4))
		while [ $timeout -gt 0 ]; do
			echo -en "${BLUE}\rWaiting as requested... ${NORMAL}$(($timeout / 4)) "
			timeout=$(($timeout - 1))
			sleep 0.25
			blkid -lt $dev >/dev/null && timeout=0
		done
		echo
		;;
		*) sleep "$WAITUSB" ;;
	esac
)

modprobe loop 2>/dev/null
modprobe ohci_hcd

#echo "${BLUE}Scanning hard disk partitions to create ${YELLOW}/etc/fstab ${NORMAL}"
#/usr/sbin/rebuildfstab & fstab_pid=$!

mv /tmp/98-tc.rules /etc/udev/rules.d/. 2>/dev/null
/sbin/udevadm control --reload-rules &

if [ -n "$SYSLOG" ]; then
	 [ -z "$RSYSLOG" ] || SOPTS=" -L -R $RSYSLOG "
	 /sbin/syslogd ${SOPTS} && echo "${GREEN}syslog started.${NORMAL}"
	 /sbin/klogd && echo "${GREEN}klog started."
fi

[ -n "$LANGUAGE" ] || LANGUAGE="C"
log_msg "Setting Language to $LANGUAGE"
echo -n "${GREEN}Setting Language to ${MAGENTA}$LANGUAGE"
echo "LANG=$LANGUAGE" > /etc/sysconfig/language
export LANG=$LANGUAGE

echo "${GREEN} Done.${NORMAL}"

if [ -n "$TZ" ]; then
	echo -n "${GREEN}Setting Timezone to ${MAGENTA}$TZ"
	export TZ && echo "TZ=$TZ" > /etc/sysconfig/timezone
	echo "${GREEN} Done.${NORMAL}"
fi

if [ -n "$NORTC" ]; then
	echo "${BLUE}Skipping rtc as requested from the boot command line.${NORMAL}"
else
	while [ ! -e /dev/rtc0 ]; do usleep 50000; done
	if [ -n "$NOUTC" ]; then
		hwclock -l -s &
	else
		hwclock -u -s &
	fi
fi

if [ -n "$HOST" ]; then
	sethostname
else
	/bin/hostname -F /etc/hostname
fi

log_msg "config 127.0.0.1"
/sbin/ifconfig lo 127.0.0.1 up
/sbin/route add 127.0.0.1 lo &

if [ -n "$STATICIPADDRESS" ]; then
        if [ -z "$STATICIFACE" ]; then
          STATICIFACE=eth0
        fi
	ifconfig $STATICIFACE $STATICIPADDRESS up
        NODHCP=1
	echo "${BLUE} Static ip address: $STATICIFACE / $STATICIPADDRESS ${NORMAL}"
fi

wait4Server() {
  log_msg "dhcp.sh runs udhcpc async, so it exits before network is up"
	/etc/init.d/dhcp.sh
	SERVER=$1 ; NOPING=$2 ; CNT=0
	if [ "$NOPING" == "1" ] ; then
		until ifconfig | grep -q Bcast
		do
			[ $((CNT++)) -gt 60 ] && break || sleep 1
		done
		sleep 1
	else
		until ping -c 1 $SERVER >/dev/null 2>&1
		do
			[ $((CNT++)) -gt 60 ] && break || sleep 1
		done
	fi
	DHCP_RAN=1
}

if ! grep "^docker" /etc/passwd >/dev/null; then addUser; fi

echo "docker" > /etc/sysconfig/tcuser
mkdir -p /home/docker

if [ -n "$SUPERUSER" ]; then
	touch /etc/sysconfig/superuser
fi

#/etc/rc.d/server_scaleway
#/etc/rc.d/server_vultr

log_msg "Setup base directories for TCE Applicatons"
[ -d "$TCEINSTALLED" ] || mkdir "$TCEINSTALLED"
[ -d "$TCEDIR" ] || mkdir "$TCEDIR"
[ -d "$TCEOPT" ] || mkdir "$TCEOPT"
[ -d "$TCLOOP" ] || mkdir "$TCLOOP"
ln -sf "$TCEDIR" /etc/sysconfig/tcedir
chown docker "$TCEOPT"
chgrp staff "$TCEDIR" "$TCEOPT" "$TCEINSTALLED" "$TCLOOP"
chmod g+w "$TCEDIR" "$TCEOPT" "$TCEINSTALLED" "$TCLOOP"

chmod u+s /bin/busybox.suid /usr/bin/sudo

get_app() {
  log_msg "get_app $1 $2"
	LOADER="tce-load -i" ; PKG=optional
	PROTO=$1
	HOST=${2%%/*}
	REST=${2#*/}
	LENG=$((${#HOST}-1)) ; LAST=${HOST:$LENG:1}
	[ "$LAST" == ":" ] && HOST=${HOST:0:$LENG}
	FILE=${REST%:*}
	NAME=${FILE##*/}
	OPTS=${REST#*:}
	[ "$OPTS" == "no-ping" ] && NOPING=1 || NOPING=0
	[ -z "$DHCP_RAN" ] && wait4Server $HOST $NOPING
	(	TCE=/tmp/tce/$PKG
		cd $TCE
		[ "$PROTO" = "TFTP" ] && tftp -g -r $FILE $HOST
		[ "$PROTO" = "HTTP" ] && wget -q http://${HOST}/${FILE}
		[ $SHOWAPPS ] && echo -ne "${BLUE}TFTP Loading Extensions ${YELLOW}"
		dos2unix -u $NAME
		while read FILE FL
		do
			APP=${FILE##*/}
			[ "$PROTO" = "TFTP" ] && tftp -g -r $FILE $HOST
			[ "$PROTO" = "HTTP" ] && wget -q http://${HOST}/${FILE}
			[ $SHOWAPPS ] && echo -ne "$APP "
			su docker -c "$LOADER $FL $TCE/$APP"
			[ "$FL" == "-c" ] && rm $APP
		done < $NAME
		[ $SHOWAPPS ] && echo "${GREEN} Done.${NORMAL}"
		rm $NAME
	)
}

log_msg "Preload drivers needed for tce/opt/home on lvm/RAID etc"
if [ -n "$PRETCE" ]; then
	PKG=optional ; LOADER="tce-load -i" ; LIST=onboot.lst
	RAM=/tmp/tce
	CPTOFS=""
	if [ "$PRETCE" == "RAM" ] ; then
		SRC=$RAM
		[ -f $SRC/copy2fs.flg ] && CPTOFS=1
	else
		PPATH=${PRETCE%%/*}
		mkdir -p /mnt/$PPATH
		mount /dev/$PPATH /mnt/$PPATH
		SRC=/mnt/$PRETCE
		[ -x $SRC/onpre.sh ] && cp $SRC/onpre.sh /tmp
		[ -f $SRC/copy2fs.flg ] && CPTOFS=1
		if [ $CPTOFS ] ; then
			cp $SRC/$PKG/* $RAM/$PKG/
			cp $SRC/$LIST $RAM/
			SRC=$RAM
			umount /mnt/$PPATH 2>/dev/null
		fi
	fi
	MNT=""
	while read NAME OPT
	do
		[ $CPTOFS ] || grep -q $NAME $SRC/copy2fs.lst 2>/dev/null && FL="-c" || FL=''
		[ $FL ] || MNT=1
		su docker -c "/usr/bin/$LOADER $SRC/$PKG/$NAME"
		[ "$SRC" == "$RAM" ] && [ "$FL" == "-c" ] && rm $RAM/$PKG/$NAME
	done < $SRC/$LIST
	[ "$SRC" != "$RAM" ] && [ $MNT ] || umount /mnt/$PPATH 2>/dev/null
	rm $RAM/copy2fs.flg $RAM/copy2fs.lst 2>/dev/null
	[ -x /tmp/onpre.sh ] && /tmp/onpre.sh
fi

#log_msg "squashfs: First process tftp and http entries"
#modprobe -q squashfs 2>/dev/null
#[ -n "$TFTPLIST" ] && get_app "TFTP" $TFTPLIST
#[ -n "$HTTPLIST" ] && get_app "HTTP" $HTTPLIST

if [ -n "$NFSMOUNT" ]; then
	SERVER=$( echo $NFSMOUNT | awk -F: '{ print $1 }')
	DIR=$(    echo $NFSMOUNT | awk -F: '{ print $2 }')
	OPTS=$(   echo $NFSMOUNT | awk -F: '{ print $3 }')
	[ "$OPTS" == "no-ping" ] && NOPING=1 || NOPING=0
	[ -z "$DHCP_RAN" ] && wait4Server $SERVER $NOPING

	#wait $fstab_pid
	if [ -x /usr/local/etc/init.d/nfs-client ] ; then
	   /usr/local/etc/init.d/nfs-client start
	   NOLOCK="";
	else
	   NOLOCK=",nolock"
	fi
	echo "${SERVER}:${DIR} /mnt/nfs nfs defaults${NOLOCK} 0 0" >> /etc/fstab
	[ $SHOWAPPS ] && echo "Mounting ${SERVER}:${DIR}"
	mkdir /mnt/nfs
	mount /mnt/nfs >/dev/null 2>&1
fi

touch /var/tmp/k5_skip
if [ -n "$NBD" ]; then
	modprobe -q nbd
	SERVER=$( echo $NBD | awk -F: '{ print $1 }')
	PORT=$(    echo $NBD | awk -F: '{ print $2 }')
	OPTS=$(   echo $NBD | awk -F: '{ print $3 }')
	[ "$OPTS" == "no-ping" ] && NOPING=1 || NOPING=0
	[ -z "$DHCP_RAN" ] && wait4Server $SERVER $NOPING
	nbd-client $SERVER $PORT /dev/nbd0
	mkdir /mnt/nbd0
	mount /dev/nbd0 /mnt/nbd0 2>&1
	pidof nbd-client nbd0 >> /var/tmp/k5_skip
fi

if grep -q "^/dev/root" /proc/mounts; then
	INSTALLED=1
	echo "${RED}Detected Traditional Hard drive installation.${NORMAL}"
fi

if [ -n "$LAPTOP" ]; then
	modprobe ac && modprobe battery 2>/dev/null
	modprobe yenta_socket >/dev/null 2>&1 || modprobe i82365 >/dev/null 2>&1
	/sbin/udevadm trigger 2>/dev/null >/dev/null &
	echo "${GREEN}Laptop options enabled (AC, Battery and PCMCIA).${NORMAL}"
fi

#wait $fstab_pid
#/sbin/swapon -a 2>/dev/null
#if [ "$?" == 0 ]; then echo "${GREEN}Possible swap partition(s) enabled.${NORMAL}"; fi


[ -n "$KEYMAP" ] || KEYMAP="us"
if [ -f "/usr/share/kmap/$KEYMAP.kmap" ]; then
	echo -n "${GREEN}Setting keymap to ${MAGENTA}$KEYMAP"
	/sbin/loadkmap < /usr/share/kmap/$KEYMAP.kmap
	echo "KEYMAP=$KEYMAP" > /etc/sysconfig/keymap
	echo "${GREEN} Done.${NORMAL}"
fi

if [ -n "$ROOT_PASSWORD" ]; then
	echo "root:$ROOT_PASSWORD" | chpasswd -m
fi

[ -n "$XVESA" ]  && sed -i 's/1024x768x32/'"$XVESA"'/' /home/docker/.xsession 2>/dev/null

log_msg "If ntpserver: $NTPSERVER is specified use that"
if [ -n "$NTPSERVER" ]; then
	echo "$NTPSERVER" > /etc/sysconfig/ntpserver
else
	[ -s /etc/sysconfig/ntpserver ] && NTPSERVER=`cat /etc/sysconfig/ntpserver`
fi

if [ -n "$NORESTORE" ]; then
	echo "${GREEN}Skipping restore as requested from the command line.${NORMAL}"
else
	TCEDIR=`readlink /etc/sysconfig/tcedir`
	/etc/init.d/tc-restore.sh "$TCEDIR"
fi

# After restore items
if [ -n "$NODHCP" ]; then
	echo "${GREEN}Skipping DHCP broadcast/network detection as requested on boot commandline.${NORMAL}"
else
	[ -z "$DHCP_RAN" ] && /etc/init.d/dhcp.sh &
	[ -z "$NORTC" ] || /etc/init.d/settime.sh &
fi


/sbin/loadcpufreq 2>/dev/null &

[ -n "$NODOCKERSTART" ] && touch $BOOT_DIR/init.d/nodockerstart
[ -n "$NOAUTOLOGIN" ] && echo "booting" > /etc/sysconfig/noautologin


log_msg "setup /home/docker for mountOnGreen"
DOCKER_HOME_DIR=/home/docker

if ( ! mountedOnGreen docker_home ); then
        log_msg "mount zfs /home/docker"
				[ -d ${DOCKER_HOME_DIR} ] && mv ${DOCKER_HOME_DIR} ${DOCKER_HOME_DIR}.tmp
				mkdir -p ${DOCKER_HOME_DIR}
	      zfs mount green/docker_home -o mountpoint ${DOCKER_HOME_DIR}
				[ -d ${DOCKER_HOME_DIR}.tmp ] && mv ${DOCKER_HOME_DIR}.tmp/* ${DOCKER_HOME_DIR}/
        chown -R docker:docker ${DOCKER_HOME_DIR}
				[ -d ${DOCKER_HOME_DIR}.tmp ] && rm -f ${DOCKER_HOME_DIR}.tmp

        if ( mountedOnGreen docker_home ) ; then
	          echo "${GREEN}Docker zfs home mount SUCCESS.${NORMAL}"
        else
	          echo "${RED}Docker zfs home mount ERROR!${NORMAL}"
        fi
fi

/opt/bootscript.sh
