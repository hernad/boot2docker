#!/bin/sh
# docker daemon start script
[ $(id -u) = 0 ] || { echo 'must be root' ; exit 1; }

# docker-machine generated profile, /opt/boot = /var/lib/boot2docker
BOOT2DOCKER_PROFILE=/var/lib/boot2docker/profile
if [ -f $BOOT2DOCKER_PROFILE ] ; then
  . $BOOT2DOCKER_PROFILE
  # ignore docker-machine generated DOCKER_STORAGE
  unset DOCKER_STORAGE DOCKER_HOST
fi


. /etc/green_common

DOCKER_PID=/var/run/docker.pid

PATH=:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/opt/docker/bin

CNT=1
while [ ! -f /opt/docker/bin/dockerd  ] ; do
  log_msg "waiting install /tmp/dockerd $CNT ..."
  sleep 30
  let CNT=$CNT+1

  if [ $CNT -eq 3  ] || [ $CNT -eq 6 ]  || [ $CNT -eq 10 ] ; then
    /usr/local/bin/install_green_apps &
  fi

  if [ $CNT -eq 20  ] ; then
     log_msg "docker wait timeout 10 minutes"
     exit 1
  fi
done


if [ ! -e $BOOT_DIR/etc/profile ]
then
  echo "# put envars  e.g. GREEN_APPS, HTTP_PROXY, HTTPS_PROXY, DOCKER_OPTS, DOCKER_STORAGE, DOCKER_LOGFILE, CERT_INTERFACES, CERT_DIR" > $BOOT_DIR/etc/profile
fi

. $BOOT_DIR/etc/profile

: ${DOCKER_HOST:='-H tcp://0.0.0.0:2376'}
: ${DOCKER_TLS:=auto}

if [ -z "$DOCKER_STORAGE" ] ; then

  if ( is_vbox )
  then
     DOCKER_STORAGE=zfs
     DOCKER_DIR=/green/docker
  else
     if [ -e /dev/zvol/green/docker_vol ] ; then
        if [ ! -d /var/lib/docker/overlay ] ; then
          DOCKER_STORAGE=overlay2 # best choice!
        else
          DOCKER_STORAGE=overlay # legacy
        fi
     fi
  fi
fi

: ${DOCKER_DIR:=/var/lib/docker}
: ${DOCKER_ULIMITS:=1048576}
: ${DOCKER_LOGFILE:=$BOOT_DIR/log/docker.log}

: ${CERT_DIR:=$BOOT_DIR/tls/}
: ${CERT_INTERFACES:='eth0 eth1'}
: ${CACERT:="${CERT_DIR}ca.pem"}
: ${CAKEY:="${CERT_DIR}cakey.pem"}
: ${SERVERCERT:="${CERT_DIR}server.pem"}
: ${SERVERKEY:="${CERT_DIR}serverkey.pem"}

# client certificates
: ${CERT:="${CERT_DIR}cert.pem"}
: ${KEY:="${CERT_DIR}key.pem"}

start() {
    # Not enabling Docker daemon TLS by default.
    if [ "$DOCKER_TLS" != "no" ]; then
        CERTHOSTNAMES="$(hostname -s),$(hostname -i)"
        for interface in ${CERT_INTERFACES}; do
          IP=$(ip addr show ${interface} |sed -nEe 's/^[ \t]*inet[ \t]*([0-9.]+)\/.*$/\1/p')
          if [ "$IP" != "" ]; then
            CERTHOSTNAMES="$CERTHOSTNAMES,$IP"
          fi
        done
        echo "Need TLS certs for $CERTHOSTNAMES"
        echo "-------------------"

        mkdir -p "$CERT_DIR"
        chmod 700 "$CERT_DIR"
        if [ ! -f "$CACERT" ] || [ ! -f "$CAKEY" ]; then
            echo "Generating CA cert"
            generate_cert --cert="$CACERT" --key="$CAKEY"
            rm "$SERVERCERT" "$SERVERKEY" "$CERT" "$KEY" "$CERT_DIR/hostnames"
        fi

        CERTSEXISTFOR=$(cat "$CERT_DIR/hostnames" 2>/dev/null)
        if [ "$CERTHOSTNAMES" != "$CERTSEXISTFOR" ]; then
            echo "Generate server cert"
            log_msg generate_cert --host="$CERTHOSTNAMES" --ca="$CACERT" --ca-key="$CAKEY" --cert="$SERVERCERT" --key="$SERVERKEY"
            generate_cert --host="$CERTHOSTNAMES" --ca="$CACERT" --ca-key="$CAKEY" --cert="$SERVERCERT" --key="$SERVERKEY"
            echo "$CERTHOSTNAMES" > "$CERT_DIR/hostnames"
        fi


        if [ "$DOCKER_TLS" == "auto" ]; then
            DOCKER_HOST='-H tcp://0.0.0.0:2376'
            DOCKER_OPTS="$DOCKER_OPTS --tlsverify --tlscacert=$CACERT --tlscert=$SERVERCERT --tlskey=$SERVERKEY"
        elif [ "$DOCKER_TLS" != "no" ]; then
            DOCKER_OPTS="$DOCKER_OPTS $DOCKER_TLS --tlscacert=$CACERT --tlscert=$SERVERCERT --tlskey=$SERVERKEY"
        fi

        # client certificates are responsibility of docker-machine

        #if [ ! -f "$CERT" ] || [ ! -f "$KEY" ]; then
        #    echo "Generating client cert"
        #    generate_cert --ca="$CACERT" --ca-key="$CAKEY" --cert="$CERT" --key="$KEY"
        #fi

        # now make the client certificates available to the docker user
        #USERCFG="/home/docker/.docker"
        #mkdir -p "$USERCFG"
        #chmod 700 "$USERCFG"
        #cp "$CACERT" "$USERCFG"
        #cp "$CERT" "$USERCFG"
        #cp "$KEY" "$USERCFG"
        #chown -R docker:docker /home/docker
    fi

    mkdir -p "$DOCKER_DIR"

    if [ "$DOCKER_STORAGE" != 'auto' ]; then
        # in the general case, let's trust Docker to "do the right thing"
        DOCKER_OPTS="$DOCKER_OPTS --storage-driver=$DOCKER_STORAGE"
    fi

    # Increasing the number of open files and processes by docker
    ulimit -n $DOCKER_ULIMITS
    ulimit -p $DOCKER_ULIMITS

    echo docker daemon --debug=false --graph=$DOCKER_DIR -H unix:// $DOCKER_HOST $DOCKER_OPTS  >> $DOCKER_LOGFILE
    dockerd --debug=false --graph=$DOCKER_DIR -H unix:// $DOCKER_HOST $DOCKER_OPTS >> $DOCKER_LOGFILE 2>&1 &
}

stop() {
    kill $(cat $DOCKER_PID)
    killall dockerd
    killall dockerd
    killall dockerd
}

restart() {
    if check
    then
        stop && sleep 1 && start
        if check
        then
           echo restart SUCCESS
        else
           echo restart ERROR
        fi
    else
        start
    fi
}

check() {

    [ ! -f $DOCKER_PID ] &&  return 1
    ps $(cat $DOCKER_PID)  | grep -v grep | grep -q dockerd
    return $?

}

status() {
    if check; then
        echo 'Docker daemon is running'
        exit 0
    else
        echo 'Docker daemon is not running'
        exit 1
    fi
}

case $1 in
    start) start;;
    stop) stop;;
    restart) restart;;
    status) status;;
    *) echo "Usage $0 {start|stop|restart|status}"; exit 1
esac
